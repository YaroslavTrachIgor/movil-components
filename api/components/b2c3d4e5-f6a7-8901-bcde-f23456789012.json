{
  "id": "b2c3d4e5-f6a7-8901-bcde-f23456789012",
  "name": "Neumorphic TrackPad",
  "description": "Customizable two-axis trackpad control with neumorphic design, haptic feedback, and smooth animations. Features a styleable protocol system, value display pills, and edge detection with haptic responses. Perfect for game controls, creative tools, and precision input interfaces.",
  "category": "utilities",
  "platform": "iOS",
  "swiftUICode": "import SwiftUI\n\nprivate struct NeumorphicTrackPadStyle: TrackPadStyle {\n    func makeThumb(configuration: TrackPadConfiguration) -> some View {\n        let base = Circle()\n            .fill(\n                LinearGradient(\n                    colors: [Color.white.opacity(0.95), Color.white.opacity(0.7)],\n                    startPoint: .topLeading,\n                    endPoint: .bottomTrailing\n                )\n            )\n            .overlay(\n                Circle().stroke(Color.white, lineWidth: 1)\n            )\n            .shadow(\n                color: Color.gray.opacity(configuration.isActive ? 0.25 : 0.15),\n                radius: configuration.isActive ? 10 : 6,\n                x: configuration.isActive ? 6 : 4,\n                y: configuration.isActive ? 6 : 4\n            )\n            .shadow(color: Color.gray.opacity(0.1), radius: configuration.isActive ? 6 : 4, x: -2, y: -2)\n            .frame(width: 44, height: 44)\n        return base\n            .scaleEffect(configuration.isActive ? 1.06 : 1.0)\n            .animation(.spring(response: 0.25, dampingFraction: 0.8), value: configuration.isActive)\n    }\n    \n    func makeTrack(configuration: TrackPadConfiguration) -> some View {\n        RoundedRectangle(cornerRadius: 18, style: .continuous)\n            .fill(.thinMaterial)\n    }\n}\n\nprivate struct TrackPadDemoView: View {\n    @State private var point: CGPoint = CGPoint(x: 0.5, y: 0.5)\n\n    var body: some View {\n        ZStack {\n            LinearGradient(\n                colors: [Color(.systemGroupedBackground), Color(.systemGroupedBackground).opacity(0.35)],\n                startPoint: .topLeading,\n                endPoint: .bottomTrailing\n            )\n            .ignoresSafeArea()\n\n            VStack(spacing: 24) {\n                VStack(alignment: .leading, spacing: 24) {\n                    VStack(alignment: .leading, spacing: 4) {\n                        Text(\"Pro TrackPad\")\n                            .font(.system(size: 28, weight: .semibold))\n                            .foregroundStyle(.primary.opacity(0.8))\n                        Text(\"Twoâ€‘axis control with haptics and styling\")\n                            .font(.subheadline)\n                            .foregroundStyle(.secondary)\n                    }\n                    \n                    VStack(spacing: 16) {\n                        TrackPad($point, range: 0...1)\n                            .frame(height: 220)\n                            .trackPadStyle(NeumorphicTrackPadStyle())\n                            .overlay {\n                                RoundedRectangle(cornerRadius: 20)\n                                    .strokeBorder(Color.gray.opacity(0.15), lineWidth: 1)\n                            }\n                        \n                        HStack(spacing: 8) {\n                            ValuePill(title: \"X\", value: point.x)\n                            ValuePill(title: \"Y\", value: point.y)\n                            Button(action: { point = CGPoint(x: 0.5, y: 0.5) }) {\n                                Label(\"Center Thumb\", systemImage: \"dot.circle.and.hand.point.up.left.fill\")\n                                    .font(.callout.weight(.regular))\n                                    .padding(.horizontal, 16)\n                                    .padding(.vertical, 8)\n                                    .background(\n                                        Capsule().fill(.thinMaterial)\n                                    )\n                                    .overlay(\n                                        Capsule()\n                                            .strokeBorder(Color.gray.opacity(0.15), lineWidth: 1)\n                                    )\n                            }\n                            .buttonStyle(.plain)\n                        }\n                    }\n                }\n                .padding(.horizontal)\n\n                VStack(spacing: 8) {\n                    Text(\"Drag anywhere inside the pad.Edges provide haptic feedback.\")\n                        .font(.footnote)\n                        .foregroundStyle(.secondary)\n                        .multilineTextAlignment(.center)\n                }\n\n                Spacer(minLength: 0)\n            }\n            .padding(.top, 32)\n            .padding(.bottom, 24)\n            .padding(.horizontal, 16)\n        }\n    }\n}\n\nprivate struct ValuePill: View {\n    let title: String\n    let value: CGFloat\n\n    var body: some View {\n        HStack(spacing: 8) {\n            Text(title)\n                .font(.caption.weight(.semibold))\n                .foregroundStyle(.secondary)\n            Text(String(format: \"%.2f\", value))\n                .font(.callout.monospacedDigit())\n                .foregroundStyle(.primary)\n        }\n        .padding(.horizontal, 12)\n        .padding(.vertical, 8)\n        .background(\n            Capsule().fill(.thinMaterial)\n        )\n        .overlay(\n            Capsule().strokeBorder(Color.gray.opacity(0.15), lineWidth: 1)\n        )\n    }\n}\n\npublic struct TrackPadConfiguration {\n    public let isDisabled: Bool\n    public let isActive: Bool\n    public let pctX: Double\n    public let pctY: Double\n    public let valueX: Double\n    public let valueY: Double\n    public let minX: Double\n    public let maxX: Double\n    public let minY: Double\n    public let maxY: Double\n}\n\npublic protocol TrackPadStyle {\n    associatedtype Thumb: View\n    associatedtype Track: View\n    \n    func makeThumb(configuration:  TrackPadConfiguration) -> Self.Thumb\n    func makeTrack(configuration:  TrackPadConfiguration) -> Self.Track\n}\n\npublic extension TrackPadStyle {\n    func makeThumbTypeErased(configuration:  TrackPadConfiguration) -> AnyView {\n        AnyView(self.makeThumb(configuration: configuration))\n    }\n    func makeTrackTypeErased(configuration:  TrackPadConfiguration) -> AnyView {\n        AnyView(self.makeTrack(configuration: configuration))\n    }\n}\n\npublic struct AnyTrackPadStyle: TrackPadStyle {\n    private let _makeThumb: (TrackPadConfiguration) -> AnyView\n    public func makeThumb(configuration: TrackPadConfiguration) -> some View {\n        self._makeThumb(configuration)\n    }\n    private let _makeTrack: (TrackPadConfiguration) -> AnyView\n    public func makeTrack(configuration: TrackPadConfiguration) -> some View  {\n        self._makeTrack(configuration)\n    }\n    \n    public init<S: TrackPadStyle>(_ style: S) {\n        self._makeThumb = style.makeThumbTypeErased\n        self._makeTrack = style.makeTrackTypeErased\n    }\n}\n\npublic struct TrackPadStyleKey: EnvironmentKey {\n    public static let defaultValue: AnyTrackPadStyle = AnyTrackPadStyle(DefaultTrackPadStyle())\n}\n\nextension EnvironmentValues {\n    public var trackPadStyle: AnyTrackPadStyle {\n        get {\n            return self[TrackPadStyleKey.self]\n        }\n        set {\n            self[TrackPadStyleKey] = newValue\n        }\n    }\n}\n\nextension View {\n    public func trackPadStyle<S>(_ style: S) -> some View where S: TrackPadStyle {\n        self.environment(\\.trackPadStyle, AnyTrackPadStyle(style))\n    }\n}\n\npublic struct DefaultTrackPadStyle: TrackPadStyle {\n    public init() { }\n    public func makeThumb(configuration:  TrackPadConfiguration) -> some View {\n        Circle()\n            .fill(configuration.isActive ? Color.yellow : Color.black)\n            .frame(width: 40, height: 40)\n    }\n    \n    public func makeTrack(configuration:  TrackPadConfiguration) -> some View {\n        RoundedRectangle(cornerRadius: 5)\n            .fill(Color.gray)\n            .overlay(RoundedRectangle(cornerRadius: 5).stroke(Color.blue))\n    }\n}\n\npublic struct TrackPad: View {\n    \n    @Environment(\\.trackPadStyle) private var style: AnyTrackPadStyle\n    \n    private let space: String = \"Track Pad\"\n    \n    @State private var isActive: Bool = false\n    @State private var atXLimit: Bool = false\n    @State private var atYLimit: Bool = false\n    \n    @Binding public var value: CGPoint\n    \n    public var rangeX: ClosedRange<CGFloat> = 0...1\n    public var rangeY: ClosedRange<CGFloat> = 0...1\n    public var isDisabled: Bool = false\n    public init(value: Binding<CGPoint>, rangeX: ClosedRange<CGFloat>, rangeY: ClosedRange<CGFloat>, isDisabled: Bool = false){\n        self._value = value\n        self.rangeX = rangeX\n        self.rangeY = rangeY\n        self.isDisabled = isDisabled\n    }\n\n    public init(_ value: Binding<CGPoint>){\n        self._value = value\n    }\n    \n    public init(_ value: Binding<CGPoint>, range: ClosedRange<CGFloat>){\n        self._value = value\n        self.rangeX = range\n        self.rangeY = range\n    }\n    \n    private var configuration: TrackPadConfiguration {\n        .init(\n            isDisabled: isDisabled,\n            isActive: isActive,\n            pctX: Double((value.x - rangeX.lowerBound)/(rangeX.upperBound - rangeX.lowerBound)),\n            pctY: Double((value.y - rangeY.lowerBound)/(rangeY.upperBound - rangeY.lowerBound)),\n            valueX: Double(value.x),\n            valueY: Double(value.y),\n            minX: Double(rangeX.lowerBound),\n            maxX: Double(rangeX.upperBound),\n            minY: Double(rangeY.lowerBound),\n            maxY: Double(rangeY.upperBound)\n        )\n    }\n    \n    func constrainValue(_ proxy: GeometryProxy, _ location: CGPoint) {\n        let w = proxy.size.width\n        let h = proxy.size.height\n        let pctX = (location.x / w).clamped(to: 0...1)\n        let pctY = (location.y / h).clamped(to: 0...1)\n        if pctX == 1 || pctX == 0 {\n            if !self.atXLimit {\n                self.impactOccured()\n            }\n            self.atXLimit = true\n        } else {\n            self.atXLimit = false\n        }\n        if pctY == 1 || pctY == 0 {\n            if !self.atYLimit {\n                self.impactOccured()\n            }\n            self.atYLimit = true\n        } else {\n            self.atYLimit = false\n        }\n        let newX = pctX*(rangeX.upperBound-rangeX.lowerBound) + rangeX.lowerBound\n        let newY = pctY*(rangeY.upperBound-rangeY.lowerBound) + rangeY.lowerBound\n        self.value = CGPoint(x: newX, y: newY)\n    }\n    private func thumbOffset(_ proxy: GeometryProxy) -> CGSize {\n        let w = proxy.size.width\n        let h = proxy.size.height\n        let pctX = (value.x - rangeX.lowerBound)/(rangeX.upperBound - rangeX.lowerBound)\n        let pctY = (value.y - rangeY.lowerBound)/(rangeY.upperBound - rangeY.lowerBound)\n        return CGSize(width: w*(pctX-0.5), height: h*(pctY-0.5))\n    }\n\n    private func impactOccured() {\n        #if os(macOS)\n        #else\n        let generator = UIImpactFeedbackGenerator(style: .medium)\n        generator.impactOccurred()\n        #endif\n    }\n    \n    public var body: some View {\n        ZStack {\n            style.makeTrack(configuration: configuration)\n            GeometryReader { proxy in\n                ZStack(alignment: .center) {\n                    self.style.makeThumb(configuration: self.configuration)\n                        .offset(self.thumbOffset(proxy))\n                        .gesture(\n                            DragGesture(minimumDistance: 0, coordinateSpace: .named(self.space))\n                                .onChanged({\n                                    self.constrainValue(proxy, $0.location)\n                                    self.isActive = true\n                                })\n                                .onEnded({\n                                    self.constrainValue(proxy, $0.location)\n                                    self.isActive = false\n                                }))\n\n                }\n                .frame(width: proxy.size.width, height: proxy.size.height)\n            }\n        }\n        .coordinateSpace(name: space)\n    }\n}\n\nprivate extension Comparable {\n    func clamped(to limits: ClosedRange<Self>) -> Self {\n        if self < limits.lowerBound { return limits.lowerBound }\n        if self > limits.upperBound { return limits.upperBound }\n        return self\n    }\n}",
  "tags": [
    "trackpad",
    "control",
    "neumorphic",
    "haptic",
    "input",
    "game"
  ],
  "imageURLs": [],
  "fileURLs": [],
  "isFavorite": false,
  "createdAt": "2025-12-11T00:00:00Z",
  "updatedAt": "2025-12-11T00:00:00Z"
}
